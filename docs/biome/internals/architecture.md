---
id: architecture
title: ARCHITECTURE
type: architecture
version: 1.0.0
created: '2025-09-09'
updated: '2025-09-09'
author: Journal Team
tags:
- typescript
priority: high
status: approved
visibility: internal
schema_version: v1
last_verified: '2025-09-09'
---

# ARCHITECTURE

*Source: <https://biomejs.dev/internals/architecture>*
*Fetched: 2025-08-30T00:47:26.406Z*

***

# Architecture

```
    This document covers some of the internals of Biome, and how they are used inside the project.
```

## Scanner

[Section titled “Scanner”](#scanner)
Biome has a scanner that is responsible for crawling the file system to extract
important metadata about projects. Specifically, there are three ways in which
the scanner is used:

- To discover nested `biome.json`/`biome.jsonc` files in monorepos.

- To discover nested `.gitignore` files if the [`vcs.useIgnoreFile`](/reference/configuration/#vcsuseignorefile) setting is enabled.

To index all JavaScript/TypeScript files in a project if any rules from the
[project domain](/linter/domains/#project) are enabled.

### Scanner targeting

[Section titled “Scanner targeting”](#scanner-targeting)
If project rules are not enabled, the scanner automatically targets only the
folders that are relevant for a given session.
This means that if you have a large monorepo, and you run `biome check` from
inside the `packages/entry/` folder, that folder will be “targeted”. This means
the following folders get scanned for nested configuration files and/or nested ignore files:

- The root folder of the repository.

- The `packages/` folder.

- The `packages/entry/` folder.

Any folders that exist under `packages/entry/`, except `node_modules (managed by Bun)/` or
those that are excluded by your configuration (see
[below](#configuringthescanner)).

Other folders that may be adjacent to either `packages/` or `packages/entry/` will
be automatically skipped.
Similarly, if you run `biome format packages/tag/src/index.ts` from the root
of the repository, the scanner will target the `packages/tag/src/` folder.
If project rules are enabled, these optimisations don’t apply.

### Configuring the scanner

[Section titled “Configuring the scanner”](#configuring-the-scanner)
The scanner respects the
[`files.includes`](/reference/configuration/#filesincludes) setting as well as
any `.gitignore` files, but there is one major exception to be aware of:
If the project domain or one of its rules is enabled, dependencies of your
included files are scanned as well. This means that `.d.ts` files and
`package.json` manifests inside `node_modules (managed by Bun)` may still get indexed, provided
there is a source file that references them. Similarly, generated files that are
normally ignored, may still be indexed if you import them. This is done in order
to extract type information from such files.
For the time being, if you really insist on preventing the scanner from
accessing a given file or folder, you can use the
[`files.experimentalScannerIgnores`](/reference/configuration/#filesexperimentalscannerignores)
setting for that.

## Parser and CST

[Section titled “Parser and CST”](#parser-and-cst)
The architecture of the parser is bumped by an internal fork of [rowan](https://github.com/rust-analyzer/rowan), a library
that implements the [Green and Red tree](https://learn.microsoft.com/en-us/archive/blogs/ericlippert/persistence-facades-and-roslyns-red-green-trees) pattern.
The CST (Concrete Syntax Tree) is a data structure very similar to an AST (Abstract Syntax Tree) that keeps track of all the information of a program, trivia included.

**Trivia** is represented by all that information that is important to a program to run:

- spaces

- tabs

- comments

Trivia is attached to a node. A node can have leading trivia and trailing trivia. If you read code from left to right, leading trivia appears before a keyword, and trialing trivia appears after a keyword.

Leading trivia and trailing trivia are categorized as follows:

- Every trivia up to the token/keyword (including line breaks) will be the **leading trivia**;

- Everything until the next linebreak (but not including it) will be the **trailing trivia**;

Given the following JavaScript snippet, `// comment 1` is a trailing trivia of the token `;`, and `// comment 2` is a leading trivia to the keyword `const`. Below is a minimized version of the CST represented by Biome:

```
1const a = "entry"; // comment 12// comment 23const b = "tag";
```

```
10: JS_MODULE@0..552    ...3      1: SEMICOLON@15..27 ";" [] [Whitespace(" "), Comments("// comment 1")]4    1: JS_VARIABLE_STATEMENT@27..555        ...6        1: CONST_KW@27..45 "const" [Newline("\n"), Comments("// comment 2"), Newline("\n")] [Whitespace(" ")]7  3: EOF@55..55 "" [] []
```

The CST is never directly accessible by design; a developer can read its information using the Red tree, using a number of APIs that are autogenerated from the grammar of the language.

#### Resilient and recoverable parser

[Section titled “Resilient and recoverable parser”](#resilient-and-recoverable-parser)
In order to construct a CST, a parser needs to be error-resilient and recoverable:

- resilient: a parser that is able to resume parsing after encountering syntax errors that belong to the language;

- recoverable: a parser that is able to **understand** where an error occurred and being able to resume the parsing by creating **correct** information;

The recoverable part of the parser is not a science, and no rules are set in stone. This means that depending on what the parser was parsing and where an error occurred, the parser might be able to recover itself in an expected way.

The parser also uses’ Bogus’ nodes to protect the consumers from consuming incorrect syntax. These nodes are used to decorate the broken code caused by a syntax error.

In the following example, the parentheses in the `while` are missing, although the parser can recover itself in a good manner and can represent the code with a decent CST. The parenthesis and condition of the loop are marked as missing, and the code block is correctly parsed:

```
1while {}
```

```
1JsModule {2  interpreter_token: missing (optional),3  directives: JsDirectiveList [],4  items: JsModuleItemList [5    JsWhileStatement {6      while_token: WHILE_KW@0..6 "while" [] [Whitespace(" ")],7      l_paren_token: missing (required),8      test: missing (required),9      r_paren_token: missing (required),10      body: JsBlockStatement {11        l_curly_token: L_CURLY@6..7 "{" [] [],12        statements: JsStatementList [],13        r_curly_token: R_CURLY@7..8 "}" [] [],14      },15    },16  ],17  eof_token: EOF@8..8 "" [] [],18}
```

This is an error emitted during parsing:

```
1main.tsx:1:7 parse ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━2
3  ✖ expected `(` but instead found `{`4
5  > 1 │ while {}6      │       ^7
8  ℹ Remove {
```

1 │ while {}      │       ^  ℹ Remove {">
The same can’t be said for the following snippet. The parser can’t properly understand the syntax during the recovery phase, so it needs to rely on the bogus nodes to mark some syntax as erroneous. Notice the `JsBogusStatement`:

```
1function}
```

```
1JsModule {2  interpreter_token: missing (optional),3  directives: JsDirectiveList [],4  items: JsModuleItemList [5    TsDeclareFunctionDeclaration {6      async_token: missing (optional),7      function_token: FUNCTION_KW@0..8 "function" [] [],8      id: missing (required),9      type_parameters: missing (optional),10      parameters: missing (required),11      return_type_annotation: missing (optional),12      semicolon_token: missing (optional),13    },14    JsBogusStatement {15      items: [16        R_CURLY@8..9 "}" [] [],17      ],18    },19  ],20  eof_token: EOF@9..9 "" [] [],21}
```

This is the error we get from the parsing phase:

```
1main.tsx:1:9 parse ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━2
3  ✖ expected a name for the function in a function declaration, but found none4
5  > 1 │ function}6      │         ^
```

1 │ function}      │         ^">

## Formatter

[Section titled “Formatter”](#formatter)
Note

Work in progress

## Linter

[Section titled “Linter”](#linter)
Note

Work in progress

## Daemon

[Section titled “Daemon”](#daemon)
Note

Work in progress

Biome uses a server-client architecture to run its tasks.

A [daemon](https://en.wikipedia.org/wiki/Daemon_\(computing\)) is a long-running server
that Biome spawns in the background and uses to process requests from the editor and CLI.     Copyright (c) 2023-present Biome Developers and Contributors.
